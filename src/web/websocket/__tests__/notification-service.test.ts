/**
 * WebSocket Notification Service Tests
 * 
 * Integration tests for real-time notification broadcasting.
 */

import { jest } from '@jest/globals';\nimport { Server as SocketIOServer } from 'socket.io';\n\n// Mock dependencies\njest.mock('../../../api/proxmox-client');\njest.mock('../../../database/client');\njest.mock('../../../database/repositories/vm-repository');\njest.mock('../../../database/repositories/container-repository');\njest.mock('../../../database/repositories/node-repository');\njest.mock('../index');\n\nimport { WebSocketNotificationService } from '../notification-service';\nimport { ProxmoxClient } from '../../../api/proxmox-client';\nimport { DatabaseClient } from '../../../database/client';\nimport { VMRepository } from '../../../database/repositories/vm-repository';\nimport { ContainerRepository } from '../../../database/repositories/container-repository';\nimport { NodeRepository } from '../../../database/repositories/node-repository';\nimport {\n  broadcastInfrastructureUpdate,\n  broadcastVMUpdate,\n  broadcastContainerUpdate,\n  sendUserNotification,\n  sendSystemNotification\n} from '../index';\n\n// Test data\nconst mockVM = {\n  id: 100,\n  name: 'test-vm',\n  node: 'pve',\n  status: 'stopped',\n  uptime: 0,\n  cpuUsage: 0,\n  memoryUsage: 0,\n  updatedAt: new Date()\n};\n\nconst mockContainer = {\n  id: 200,\n  hostname: 'test-container',\n  nodeId: 'pve',\n  status: 'stopped',\n  uptime: 0,\n  cpuUsage: 0,\n  memoryUsage: 0,\n  updatedAt: new Date()\n};\n\nconst mockProxmoxVMStatus = {\n  vmid: 100,\n  status: 'running',\n  uptime: 3600,\n  cpu: 0.12,\n  mem: 1073741824\n};\n\nconst mockProxmoxContainerStatus = {\n  vmid: 200,\n  status: 'running',\n  uptime: 1800,\n  cpu: 0.08,\n  mem: 536870912\n};\n\n// Mock implementations\nconst mockIO = {\n  to: jest.fn().mockReturnThis(),\n  emit: jest.fn()\n} as unknown as SocketIOServer;\n\nconst mockVMRepo = {\n  findById: jest.fn(),\n  update: jest.fn(),\n  count: jest.fn()\n};\n\nconst mockContainerRepo = {\n  findById: jest.fn(),\n  update: jest.fn(),\n  count: jest.fn()\n};\n\nconst mockNodeRepo = {\n  count: jest.fn()\n};\n\nconst mockProxmoxClient = {\n  getVMStatus: jest.fn(),\n  getContainerStatus: jest.fn()\n};\n\n// Mock WebSocket functions\nconst mockBroadcastVMUpdate = broadcastVMUpdate as jest.Mock;\nconst mockBroadcastContainerUpdate = broadcastContainerUpdate as jest.Mock;\nconst mockBroadcastInfrastructureUpdate = broadcastInfrastructureUpdate as jest.Mock;\nconst mockSendUserNotification = sendUserNotification as jest.Mock;\nconst mockSendSystemNotification = sendSystemNotification as jest.Mock;\n\ndescribe('WebSocketNotificationService', () => {\n  let service: WebSocketNotificationService;\n\n  beforeEach(() => {\n    // Reset all mocks\n    jest.clearAllMocks();\n    \n    // Setup mock implementations\n    (DatabaseClient.getInstance as jest.Mock).mockReturnValue({});\n    (VMRepository as jest.Mock).mockImplementation(() => mockVMRepo);\n    (ContainerRepository as jest.Mock).mockImplementation(() => mockContainerRepo);\n    (NodeRepository as jest.Mock).mockImplementation(() => mockNodeRepo);\n    (ProxmoxClient as jest.Mock).mockImplementation(() => mockProxmoxClient);\n    \n    service = new WebSocketNotificationService(mockIO);\n  });\n\n  afterEach(() => {\n    service.stop();\n  });\n\n  describe('constructor and lifecycle', () => {\n    it('should create service instance', () => {\n      expect(service).toBeDefined();\n      expect(service).toBeInstanceOf(WebSocketNotificationService);\n    });\n\n    it('should start and stop service', () => {\n      const spy = jest.spyOn(global, 'setInterval');\n      \n      service.start();\n      expect(spy).toHaveBeenCalled();\n      \n      service.stop();\n      \n      spy.mockRestore();\n    });\n  });\n\n  describe('broadcastVMStatusUpdate', () => {\n    beforeEach(() => {\n      mockVMRepo.findById.mockResolvedValue(mockVM);\n      mockProxmoxClient.getVMStatus.mockResolvedValue(mockProxmoxVMStatus);\n      mockVMRepo.update.mockResolvedValue(undefined);\n    });\n\n    it('should broadcast VM status update with live data', async () => {\n      await service.broadcastVMStatusUpdate(100, 'user123', 'proxmox.test.local');\n\n      expect(mockVMRepo.findById).toHaveBeenCalledWith('100');\n      expect(mockProxmoxClient.getVMStatus).toHaveBeenCalledWith('pve', 100);\n      expect(mockBroadcastVMUpdate).toHaveBeenCalledWith(mockIO, 100, {\n        status: 'running',\n        uptime: 3600,\n        cpuUsage: 0.12,\n        memoryUsage: 1073741824,\n        liveData: true\n      });\n      expect(mockSendUserNotification).toHaveBeenCalledWith(\n        mockIO,\n        'user123',\n        expect.objectContaining({\n          type: 'info',\n          title: 'VM Status Updated',\n          message: 'VM test-vm status: running'\n        })\n      );\n    });\n\n    it('should update database with live status', async () => {\n      await service.broadcastVMStatusUpdate(100, 'user123', 'proxmox.test.local');\n\n      expect(mockVMRepo.update).toHaveBeenCalledWith('100', {\n        status: 'running',\n        uptime: 3600,\n        cpuUsage: 0.12,\n        memoryUsage: 1073741824,\n        updatedAt: expect.any(Date)\n      });\n    });\n\n    it('should handle VM not found', async () => {\n      mockVMRepo.findById.mockResolvedValue(null);\n\n      await service.broadcastVMStatusUpdate(999);\n\n      expect(mockBroadcastVMUpdate).not.toHaveBeenCalled();\n    });\n\n    it('should handle Proxmox connection errors', async () => {\n      mockProxmoxClient.getVMStatus.mockRejectedValue(new Error('Connection failed'));\n\n      await service.broadcastVMStatusUpdate(100, 'user123', 'proxmox.test.local');\n\n      // Should still broadcast with database data\n      expect(mockBroadcastVMUpdate).toHaveBeenCalledWith(mockIO, 100, {\n        status: 'stopped',\n        uptime: 0,\n        cpuUsage: 0,\n        memoryUsage: 0,\n        liveData: false\n      });\n    });\n\n    it('should work without Proxmox server', async () => {\n      await service.broadcastVMStatusUpdate(100, 'user123');\n\n      expect(mockProxmoxClient.getVMStatus).not.toHaveBeenCalled();\n      expect(mockBroadcastVMUpdate).toHaveBeenCalledWith(mockIO, 100, {\n        status: 'stopped',\n        uptime: 0,\n        cpuUsage: 0,\n        memoryUsage: 0,\n        liveData: false\n      });\n    });\n  });\n\n  describe('broadcastContainerStatusUpdate', () => {\n    beforeEach(() => {\n      mockContainerRepo.findById.mockResolvedValue(mockContainer);\n      mockProxmoxClient.getContainerStatus.mockResolvedValue(mockProxmoxContainerStatus);\n      mockContainerRepo.update.mockResolvedValue(undefined);\n    });\n\n    it('should broadcast container status update with live data', async () => {\n      await service.broadcastContainerStatusUpdate(200, 'user123', 'proxmox.test.local');\n\n      expect(mockContainerRepo.findById).toHaveBeenCalledWith('200');\n      expect(mockProxmoxClient.getContainerStatus).toHaveBeenCalledWith('pve', 200);\n      expect(mockBroadcastContainerUpdate).toHaveBeenCalledWith(mockIO, 200, {\n        status: 'running',\n        uptime: 1800,\n        cpuUsage: 0.08,\n        memoryUsage: 536870912,\n        liveData: true\n      });\n    });\n\n    it('should send user notification', async () => {\n      await service.broadcastContainerStatusUpdate(200, 'user123', 'proxmox.test.local');\n\n      expect(mockSendUserNotification).toHaveBeenCalledWith(\n        mockIO,\n        'user123',\n        expect.objectContaining({\n          type: 'info',\n          title: 'Container Status Updated',\n          message: 'Container test-container status: running'\n        })\n      );\n    });\n\n    it('should handle container not found', async () => {\n      mockContainerRepo.findById.mockResolvedValue(null);\n\n      await service.broadcastContainerStatusUpdate(999);\n\n      expect(mockBroadcastContainerUpdate).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('broadcastOperationNotification', () => {\n    it('should broadcast success notification to user', () => {\n      service.broadcastOperationNotification(\n        'create', 'vm', 100, 'test-vm', 'success', 'user123'\n      );\n\n      expect(mockSendUserNotification).toHaveBeenCalledWith(\n        mockIO,\n        'user123',\n        {\n          type: 'success',\n          title: 'VM create',\n          message: 'Successfully created vm test-vm',\n          data: {\n            operation: 'create',\n            resourceType: 'vm',\n            resourceId: 100,\n            resourceName: 'test-vm',\n            status: 'success'\n          }\n        }\n      );\n    });\n\n    it('should broadcast error notification to user', () => {\n      service.broadcastOperationNotification(\n        'start', 'container', 200, 'test-ct', 'error', 'user123', 'Connection timeout'\n      );\n\n      expect(mockSendUserNotification).toHaveBeenCalledWith(\n        mockIO,\n        'user123',\n        {\n          type: 'error',\n          title: 'CONTAINER start',\n          message: 'Failed to start container test-ct: Connection timeout',\n          data: {\n            operation: 'start',\n            resourceType: 'container',\n            resourceId: 200,\n            resourceName: 'test-ct',\n            status: 'error'\n          }\n        }\n      );\n    });\n\n    it('should broadcast system notification when no user specified', () => {\n      service.broadcastOperationNotification(\n        'update', 'vm', 100, 'system-vm', 'success'\n      );\n\n      expect(mockSendSystemNotification).toHaveBeenCalledWith(\n        mockIO,\n        expect.objectContaining({\n          type: 'success',\n          title: 'VM update',\n          message: 'Successfully updated vm system-vm'\n        })\n      );\n      expect(mockSendUserNotification).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('broadcastTaskCompletion', () => {\n    it('should broadcast task completion success', () => {\n      service.broadcastTaskCompletion(\n        'UPID:pve:123456',\n        'qmcreate',\n        'success',\n        100,\n        'new-vm',\n        'user123'\n      );\n\n      expect(mockSendUserNotification).toHaveBeenCalledWith(\n        mockIO,\n        'user123',\n        {\n          type: 'success',\n          title: 'Task Completed',\n          message: 'Task qmcreate completed successfully for new-vm',\n          data: {\n            taskId: 'UPID:pve:123456',\n            taskType: 'qmcreate',\n            status: 'success',\n            resourceId: 100,\n            resourceName: 'new-vm'\n          }\n        }\n      );\n    });\n\n    it('should broadcast task completion error', () => {\n      service.broadcastTaskCompletion(\n        'UPID:pve:789012',\n        'qmstart',\n        'error',\n        100,\n        'test-vm',\n        'user123',\n        'VM is locked'\n      );\n\n      expect(mockSendUserNotification).toHaveBeenCalledWith(\n        mockIO,\n        'user123',\n        {\n          type: 'error',\n          title: 'Task Failed',\n          message: 'Task qmstart failed: VM is locked',\n          data: {\n            taskId: 'UPID:pve:789012',\n            taskType: 'qmstart',\n            status: 'error',\n            resourceId: 100,\n            resourceName: 'test-vm'\n          }\n        }\n      );\n    });\n  });\n\n  describe('infrastructure status broadcasting', () => {\n    beforeEach(() => {\n      // Mock repository counts for infrastructure status\n      mockVMRepo.count\n        .mockResolvedValueOnce(10) // total VMs\n        .mockResolvedValueOnce(7);  // running VMs\n      \n      mockContainerRepo.count\n        .mockResolvedValueOnce(5)  // total containers\n        .mockResolvedValueOnce(3); // running containers\n      \n      mockNodeRepo.count.mockResolvedValue(2); // total nodes\n    });\n\n    it('should broadcast infrastructure status periodically', async () => {\n      service.start();\n      \n      // Wait for initial broadcast\n      await new Promise(resolve => setTimeout(resolve, 100));\n\n      expect(mockBroadcastInfrastructureUpdate).toHaveBeenCalledWith(\n        mockIO,\n        expect.objectContaining({\n          vms: {\n            total: 10,\n            running: 7,\n            stopped: 3\n          },\n          containers: {\n            total: 5,\n            running: 3,\n            stopped: 2\n          },\n          nodes: {\n            total: 2,\n            online: 2,\n            offline: 0\n          },\n          lastUpdated: expect.any(String)\n        })\n      );\n    });\n\n    it('should handle database errors during status broadcast', async () => {\n      mockVMRepo.count.mockRejectedValue(new Error('Database error'));\n      \n      service.start();\n      \n      // Wait for broadcast attempt\n      await new Promise(resolve => setTimeout(resolve, 100));\n\n      // Should not crash the service\n      expect(mockBroadcastInfrastructureUpdate).not.toHaveBeenCalled();\n    });\n  });\n});